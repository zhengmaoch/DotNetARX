# 🛡️ 线程安全优化建议

## 问题分析

当前项目的异步操作存在严重的线程安全问题：

### 1. AutoCAD事务不支持多线程
```csharp
// ❌ 当前问题代码 - AsyncOperations.cs
public async Task<AsyncOperationResult<bool>> MoveEntityAsync(...)
{
    var result = await Task.Run(() =>
    {
        // 这里在后台线程调用AutoCAD API，会导致跨线程异常
        return MoveEntity(entityId, fromPoint, toPoint);
    }, cancellationToken);
}
```

### 2. 缺乏文档锁定机制
AutoCAD的文档对象与UI线程绑定，后台线程访问需要获取文档锁。

## 解决方案

### 1. 实现正确的异步模式

```csharp
/// <summary>
/// 线程安全的异步实体操作服务
/// </summary>
public class ThreadSafeAsyncEntityService
{
    /// <summary>
    /// 正确的异步移动实体实现
    /// </summary>
    public async Task<AsyncOperationResult<bool>> MoveEntityAsync(
        ObjectId entityId,
        Point3d fromPoint,
        Point3d toPoint,
        CancellationToken cancellationToken = default)
    {
        var startTime = DateTime.Now;
        
        try
        {
            // 在UI线程上执行AutoCAD操作
            var result = await Task.FromResult(false);
            
            // 使用Application.Invoke确保在正确线程执行
            Application.DocumentManager.MdiActiveDocument.SendStringToExecute(
                $"_MOVE {entityId.Handle} {fromPoint.X},{fromPoint.Y} {toPoint.X},{toPoint.Y} ",
                false, false, false);
            
            var duration = DateTime.Now - startTime;
            return AsyncOperationResult<bool>.Successful(true, duration);
        }
        catch (Exception ex)
        {
            var duration = DateTime.Now - startTime;
            return AsyncOperationResult<bool>.Failed(ex, duration);
        }
    }

    /// <summary>
    /// 使用文档锁定的安全操作
    /// </summary>
    public async Task<T> ExecuteInDocumentContextAsync<T>(
        Document document, 
        Func<Transaction, T> operation, 
        CancellationToken cancellationToken = default)
    {
        var tcs = new TaskCompletionSource<T>();
        
        // 在文档的同步上下文中执行
        document.CommandStack.PushAsCurrentDocument(document);
        
        try
        {
            using (var docLock = document.LockDocument())
            using (var trans = document.TransactionManager.StartTransaction())
            {
                try
                {
                    var result = operation(trans);
                    trans.Commit();
                    tcs.SetResult(result);
                }
                catch (Exception ex)
                {
                    trans.Abort();
                    tcs.SetException(ex);
                }
            }
        }
        catch (Exception ex)
        {
            tcs.SetException(ex);
        }
        finally
        {
            document.CommandStack.PopAsCurrentDocument(document);
        }
        
        return await tcs.Task;
    }
}
```

### 2. 实现命令式异步操作

```csharp
/// <summary>
/// 基于命令的异步操作（推荐方式）
/// </summary>
public class CommandBasedAsyncService
{
    private readonly Dictionary<string, TaskCompletionSource<object>> _pendingOperations = new();

    public async Task<bool> MoveEntityAsync(ObjectId entityId, Point3d from, Point3d to)
    {
        var operationId = Guid.NewGuid().ToString();
        var tcs = new TaskCompletionSource<object>();
        _pendingOperations[operationId] = tcs;

        // 构建LISP命令
        var command = $"(progn " +
                     $"(setq ent (handent \"{entityId.Handle}\")) " +
                     $"(if ent " +
                     $"  (progn " +
                     $"    (command \"_MOVE\" ent \"\" \"{from.X},{from.Y}\" \"{to.X},{to.Y}\") " +
                     $"    (princ \"SUCCESS_{operationId}\") " +
                     $"  ) " +
                     $"  (princ \"ERROR_{operationId}\") " +
                     $") " +
                     $")";

        // 发送命令
        var doc = Application.DocumentManager.MdiActiveDocument;
        doc.SendStringToExecute(command, false, false, false);

        // 等待结果
        var result = await tcs.Task;
        _pendingOperations.Remove(operationId);
        
        return result.ToString().StartsWith("SUCCESS");
    }
}
```

### 3. 修复静态字段线程安全

```csharp
/// <summary>
/// 线程安全的ARX类重构
/// </summary>
public static class ARX
{
    private static readonly Lazy<bool> _initialized = new Lazy<bool>(() => {
        ServiceInitializer.Initialize();
        return true;
    });

    /// <summary>
    /// 线程安全的初始化
    /// </summary>
    public static void Initialize(Action<IServiceContainer> configure = null)
    {
        lock (_initLock)
        {
            if (_initialized.Value) return;
            ServiceInitializer.Initialize(configure);
        }
    }

    /// <summary>
    /// 线程安全的服务访问
    /// </summary>
    public static ILogger Logger => 
        ServiceLocator.Current.GetService<ILogger>() ?? LogManager.DefaultLogger;
}
```

## 实施建议

### 阶段1: 移除现有异步操作
1. 删除 `AsyncOperations.cs` 中的 `Task.Run` 调用
2. 将异步方法改为基于命令的实现

### 阶段2: 实现文档锁定机制
1. 为所有数据库操作添加文档锁定
2. 实现专用的文档上下文执行器

### 阶段3: 命令式异步重构
1. 使用AutoCAD命令系统实现异步操作
2. 通过LISP/命令回调获取操作结果

这种方案完全避免了线程安全问题，同时保持了异步编程的用户体验。